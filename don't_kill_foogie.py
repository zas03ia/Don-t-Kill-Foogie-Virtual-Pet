# -*- coding: utf-8 -*-
"""Don't Kill Foogie.ipynb

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/1lAaj9kWYT15eRYkaatVRYFIoqBJBgbS0

#FINAL CODE
"""

##### FINAL CODE



from OpenGL.GL import *
from OpenGL.GLUT import *
from OpenGL.GLU import *
import numpy as np
import math
import time

steps =8
input = ""
life=3
scale=0
stomach_size=0
rhand=[]
lhand=[]
for i in range(450, 541):
    lhand.append([i, 560])
    rhand.append([i+210, 560])
rleg=[]
lleg=[]
angh = 60
angl = 45
hcentre=[[540, 560], [660, 560]]

for i in range(300, 401):
    lleg.append([570, i])
    rleg.append([630, i])
lcentre=[[570, 400],[630, 400]]
def circlePoints(x, y, x0, y0):
    draw_points(x + x0, y + y0)
    draw_points(y + x0, x + y0)
    draw_points(y + x0, -x + y0)
    draw_points(x + x0, -y + y0)
    draw_points(-x + x0, -y + y0)
    draw_points(-y + x0, -x + y0)
    draw_points(-y + x0, x + y0)
    draw_points(-x + x0, y + y0)

def midpointcircle(radius, x0, y0):
    d = 1 - radius
    x = 0
    y = radius

    circlePoints(x, y, x0, y0)

    while x < y:
        #print("y")
        if d < 0:
            # Choose East.
            d = d + 2*x + 3
            x += 1
        else:
            # Choose South East.
            d = d + 2*x -2*y + 5
            x += 1
            y = y - 1

        circlePoints(x, y, x0, y0)

def draw_circle(radius, x0, y0):
    midpointcircle(radius/2, x0+radius/2, y0)


def findZone(x0, y0, x1, y1):
    dy = y1 - y0
    dx = x1 - x0

    if abs(dx) > abs(dy):  # Represents zone 0, 3, 4, 7.
        if dx > 0 and dy > 0:

            return 0
        elif dx < 0 and dy > 0:

            return 3
        elif dx < 0 and dy < 0:

            return 4
        else:

            return 7

    else:  # Represents zone 1, 2, 5, 6.
        if dx > 0 and dy > 0:

            return 1
        elif dx < 0 and dy > 0:

            return 2
        elif dx < 0 and dy < 0:

            return 5
        else:

            return 6

### Zone Zero Conversion Algorithm  ###

def ZoneZeroConversion(zone, x, y):
    if zone == 0:

        return x, y
    elif zone == 1:

        return y, x
    elif zone == 2:

        return -y, x
    elif zone == 3:

        return -x, y
    elif zone == 4:

        return -x, -y
    elif zone == 5:

        return -y, -x
    elif zone == 6:

        return -y, x
    elif zone == 7:

        return x, -y


### Zero to Original zone Algorithm ###

def zero_to_original_zone(zone, x, y):
    if zone == 0:
        return x, y
    if zone == 1:
        return y, x
    if zone == 2:
        return -y, -x
    if zone == 3:
        return -x, y
    if zone == 4:
        return -x, -y
    if zone == 5:
        return -y, -x
    if zone == 6:
        return y, -x
    if zone == 7:
        return x, -y

### Mid Point Line Drawing Algorithm ###

def MidPointLine(zone, x0, y0, x1, y1):
    dy = y1 - y0
    dx = x1 - x0
    d_init = 2 * dy - dx
    e = 2 * dy
    ne = 2 * (dy - dx)

    x = x0
    y = y0

    while x <= x1:

        a, b = zero_to_original_zone(zone, x, y)  # Converting the points to the original zone and then drawing it
        draw_points(a, b)

        if d_init <= 0:
            x += 1
            d_init += e

        else:
            x += 1
            y += 1
            d_init += ne

def eight_way_symmetry(x0, y0, x1, y1):
    zone = findZone(x0, y0, x1, y1)
    z0_x0, z0_y0 = ZoneZeroConversion(zone, x0, y0)
    z0_x1, z0_y1 = ZoneZeroConversion(zone, x1, y1)
    MidPointLine(zone, z0_x0, z0_y0, z0_x1, z0_y1)


# -----------------------------------------------------------

def head():
    # mouth
    draw_circle(15, 595, 650)
    # head
    draw_circle(150, 525, 675)
def eye():

    if input== 'hit':
        #glColor3f(0.0, 0.0, 1.0)
        draw_circle(10, 625, 700)
        draw_circle(10, 575, 700)
        #left eye tears
        glColor3f(0.0, 0.0, 1.0)
        draw_points(577,660)
        draw_points(577, 670)
        draw_points(577, 680)
        draw_points(577, 690)
        draw_points(577, 650)
        draw_points(577, 640)
        #right eye tears
        draw_points(630, 660)
        draw_points(630, 670)
        draw_points(630, 680)
        draw_points(630, 690)
        draw_points(630, 650)
        draw_points(630, 640)
    elif input=='feed':
         #right eye
         eight_way_symmetry(615, 700, 628, 730)
         eight_way_symmetry(628, 730, 640, 700)
         #eight_way_symmetry(628, 730, 640, 700)
         #eight_way_symmetry(628, 730, 640, 700)
         #left eye
         eight_way_symmetry(570, 700, 583, 730)
         eight_way_symmetry(583, 730, 595, 700)
         #eight_way_symmetry(575, 730, 587, 700)
         #eight_way_symmetry(628, 730, 640, 700)
    else:

         eight_way_symmetry(615, 700, 628, 730)
         eight_way_symmetry(628, 730, 640, 700)
         eight_way_symmetry(570, 700, 583, 730)
         eight_way_symmetry(583, 730, 595, 700)

def body():

    eight_way_symmetry(540,600,660,600)
    eight_way_symmetry(660,600,660,400)
    eight_way_symmetry( 540,400,660,400)
    eight_way_symmetry(540,600, 540,400)

def hand():

    for i in rhand+lhand:
        draw_points(i[0],i[1])


    palm = rhand[-1]
    draw_points(palm[0]+1, palm[1]+1, 10)
    palm = lhand[0]
    draw_points(palm[0], palm[1], 10)


def leg():
    glColor3f(1.0, 1.0, 1.0)

    for i in rleg+lleg:
        draw_points(i[0],i[1])


    palm = rleg[0]
    draw_points(palm[0]+1, palm[1]+1, 10)
    palm = lleg[0]
    draw_points(palm[0], palm[1], 10)

def whiskers():
    glColor3f(1.0, 1.0, 0.0)
    #left
    eight_way_symmetry(510, 670, 560, 670)
    eight_way_symmetry(510, 650, 560, 660)
    eight_way_symmetry(510, 630, 560, 650)
    #Right
    eight_way_symmetry(650, 670, 700, 670)
    eight_way_symmetry(650, 660, 700, 650)
    eight_way_symmetry(650, 650, 700, 630)


def ear():
    glColor3f(1.0, 1.0, 1.0)
    draw_circle(30, 510, 720)
    draw_circle(30, 660, 720)


def aghat(radius, x0, y0, scale_factor):
    global stomach_size
    glColor3f(1.0, 0, 0)
    if input=="hit" or input=="Hit":
        scale_factor= scale_factor*2
        stomach_size = 0
    elif input=="feed" or input=="Feed":
        scale_factor = scale_factor *.1
    else:
        scale_factor = scale_factor *0

    scaled_radius = radius * scale_factor
    for y in range(int(y0 - scaled_radius), int(y0 + scaled_radius)):
        for x in range(int(x0 - scaled_radius), int(x0 + scaled_radius)):
            if (x - x0) ** 2 + (y - y0) ** 2 <= scaled_radius ** 2:
                draw_points(x, y)
    midpointcircle(scaled_radius, x0, y0)

def midPoint_scaled(radius,x0, y0):
    global scale, stomach_size
    if input=="feed" or input=="Feed":
        if scale==0:
            scale+=1
            scale=scale*1.2
            stomach_size += 1
        else:
            if stomach_size < 3:
                scale = scale * 1.2
                stomach_size +=1
    else:
        scale=0
    d = 1 - radius
    x = 0
    y = radius
    scaling_matrix = np.array([[scale, 0], [0, scale]])
    values = [x, y]
    column = np.array(values).reshape(-1, 1)
    scalled = np.dot(scaling_matrix, column)
    x=scalled[0]
    y=scalled[1]
    circlePoints(x, y, x0, y0)
    while x < y:
        if d >= 0:
            d = d + 2 * x - 2 * y + 5
            x = x + 1
            y = y - 1
        else:
            d = d + 2 * x + 3
            x = x + 1
        circlePoints(x, y, x0, y0)

def cross():
    glColor3f(0.0, 1.0, 0.0)

    y0=680
    y1=640
    for i in range(life):
        eight_way_symmetry(750, y0, 770, y1)
        eight_way_symmetry(770, y0, 750, y1)
        y0 += 50
        y1 += 50
def stomach():
    glColor3f(1.0, 1.0, 0.0)
    midPoint_scaled(30, 600, 460)

def draw_points(x, y, n=None):
    if n:
        glPointSize(n)
    else:
        glPointSize(2)
    glBegin(GL_POINTS)
    glVertex2f(x, y)

    glEnd()

def iterate():
    glViewport(0, 0, 500, 500)
    glMatrixMode(GL_PROJECTION)
    glLoadIdentity()
    glOrtho(0,800 , 0, 800, .0, 1.0)
    glMatrixMode (GL_MODELVIEW)
    glLoadIdentity()

def rotation(ang, centre, points):
    ang = ang * math.pi / 180
    points1 = []

    for i in points:
        a= i[0]-centre[0]
        b = i[1]-centre[1]
        x = a * math.cos(ang) + b * (-math.sin(ang))
        y = a * math.sin(ang) + b * math.cos(ang)
        points1.append([x+centre[0], y+centre[1]])
    return points1

def timer_callback(value):
    global angh, angl, lhand, rhand, lleg, rleg, steps

    # Modify variables or update animations here
    lhand = rotation(angh, hcentre[0], lhand)
    rhand = rotation(-angh, hcentre[1], rhand)
    lleg = rotation(-angl, lcentre[0], lleg)
    rleg = rotation(angl, lcentre[1], rleg)
    angh = -angh
    angl = -angl
    glutPostRedisplay()
    time.sleep(0.5)
    steps-=1
    if steps ==0:
        steps=8
        return
    else:
        glutTimerFunc(1, timer_callback, 0)

def keyboard(key, x, y):
    global input, life

    if key == b'0':
        glutDestroyWindow(wind)
        sys.exit()
    elif key == b'1': ### Meal

        if life < 3:
            life += 1
        input = "feed"
        glutPostRedisplay()  # Trigger redraw

    elif key == b'2': ## Hit
        if life > 1:
            life -= 1
        else:
            glutDestroyWindow(wind)
            sys.exit()
        input = "hit"
        glutPostRedisplay() # Trigger redraw

    elif key == b'3': ## Dance
        glutTimerFunc(0, timer_callback, 0)


def showScreen():

    glClear(GL_COLOR_BUFFER_BIT | GL_DEPTH_BUFFER_BIT)
    glLoadIdentity()
    iterate()

    head()
    body()
    hand()
    eye ()
    aghat(20, 560, 745, .5)
    cross()
    leg()
    stomach()
    whiskers()
    ear()
    # (Red, Green, Blue)
    glColor3f(1.0, 1.0, 1.0)

    glutSwapBuffers()


glutInit()
glutInitDisplayMode(GLUT_RGBA)

# Size of the window.
# Manipulating this value will let us change the size of the output widow where the pixel is shown.
glutInitWindowSize(800, 800)

glutInitWindowPosition(5, 5)

# window name
wind = glutCreateWindow(b"Don't Kill Foogie")

glutDisplayFunc(showScreen)
glutKeyboardFunc(keyboard)
glutMainLoop()